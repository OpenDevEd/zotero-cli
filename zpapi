#!/usr/bin/env python3

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

import argparse
import sys
import os
from netrc import netrc
from munch import Munch
import toml
from pyzotero import zotero
import json

class Zotero(object):
  def __init__(self):
    # global parameters for all commands
    self.parser = argparse.ArgumentParser()
    self.parser.add_argument('--api_key')
    self.parser.add_argument('--config', type=lambda x: x if os.path.exists(x) else self.parser.error(f'config file {x} does not exist'))
    self.parser.add_argument('--library-id', type=int)
    self.parser.add_argument('--library-type', choices=['user', 'group'])
    self.parser.add_argument('--indent', type=int, default=2)

    subparsers = self.parser.add_subparsers(help='commands', dest='command', required=True)
    # add all methods that do not start with _ as a command
    for cmd in dir(self):
      if cmd[0] == '_': continue

      action = getattr(self, cmd)
      if not callable(action): continue

      sp = subparsers.add_parser(cmd.replace('_', '-'), help=action.__doc__)
      # when called with an argparser, the command is expected to add relevant parameters and return
      # the command must have a docstring
      action(sp)

    self.args = self.parser.parse_args()

    # pick up config
    if not self.args.config and os.path.exists('zpapi.toml'):
      self.args.config = 'zpapi.toml'
    if self.args.config:
      with open(self.args.config) as f:
        self.config = toml.load(f, _dict=Munch)
    else:
      self.config = toml.loads('', _dict=Munch)

    if not self.args.library_type:
      # try from the config
      self.args.library_type = self.config.get('library_type')
    if not self.args.library_type:
      self.parser.error('no library type provided')
    elif self.args.library_type not in ['user', 'group']:
      self.parser.error('library type must be "user" or "group"')

    if not self.args.library_id:
      # try from the config
      self.args.library_id = self.config.get('library_id')
      try:
        if self.args.library_id: self.args.library_id = int(self.args.library_id)
      except ValueError:
        self.parser.error(f'library ID must be numeric, not {self.args.library_id}')

    if not self.args.library_id:
      if self.args.library_type == 'group':
        self.parser.error('no library ID specified')
      else:
        self.parser.error('no user ID specified')

    if not self.args.api_key:
      self.args.api_key = self.config.get('api_key')

    if not self.args.api_key:
      self.args.api_key = os.environ.get('ZOTERO_API_KEY', None)

    if not self.args.api_key:
      info = netrc().authenticators('api.zotero.org')
      if info: self.args.api_key = info[2]

    if not self.args.api_key:
      self.parser.error('no API key provided')

    self.zotero = zotero.Zotero(self.args.library_id, self.args.library_type, self.args.api_key)

    # call the actual command
    getattr(self, self.args.command.replace('-', '_'))()

  #### THE COMMANDS ####

  def key(self, argparser=None):
    """TODO: document"""

    if argparser: return

    print(json.dumps(self.zotero.key_info(), indent = self.args.indent))

  def items(self, argparser=None):
    """TODO: document"""

    if argparser:
      group = argparser.add_mutually_exclusive_group()

      group.add_argument('--count', action='store_true')

      other = group.add_argument_group()
      other.add_argument('--filter')
      other.add_argument('--top', action='store_true')
      return

    if self.args.count:
      print(json.dumps(self.zotero.count_items(), indent=self.args.indent))
      return

    # why not as separate add_argument s?
    args = json.loads(self.args.filter) if self.args.filter else {}

    if self.args.top:
      items = self.zotero.top(**args)
    else:
      items = self.zotero.items(**args)
      if not 'limit' in args: items = self.zotero.everything(items)

    print(json.dumps(items, indent=self.args.indent))

  def publications(self, argparser=None):
    """TODO: document"""

    if argparser: return

    print(json.dumps(self.zotero.publications(), indent = self.args.indent))

  def trash(self, argparser=None):
    """TODO: document"""

    if argparser: return
    print(json.dumps(self.zotero.trash(), indent = self.args.indent))

  def deleted(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('--filter')
      return

    args = json.loads(self.args.filter) if self.args.filter else {}
    print(json.dumps(self.zotero.deleted(**args), indent = self.args.indent))

  def tags(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('--filter')
      argparser.add_argument('--count')
      return

    args = json.loads(self.args.filter) if self.args.filter else {}
    items = self.zotero.items(**args)
    if not 'limit' in args: items = self.zotero.everything(items)

    if self.args.count:
      for tag in items:
        print(f'{tag} {self.zotero.num_tagitems(tag)}')
    else:
      print(json.dumps(items, indent=self.args.indent))

  def searches(self, argparser=None):
    """TODO: document"""

    if argparser: return
    print(json.dumps(self.zotero.searches(), indent = self.args.indent))

  def saved_search(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('files', nargs='*')
      return

    if not self.args.files or len(self.args.files) == 0:
      self.parser.error('files are required for saved-search')
      return

    for search in self.args.files:
      print(f'Search file: {search}')

      with open(search) as f:
        searchdefs = json.load(f)
        for searchdef in searchdefs:
          print(f'   Adding: {mydef["name"]}')
          result = self.zotero.saved_search(mydef['name'], mydef['conditions'])
          print(json.dumps(result, indent=self.args.indent))
    print('Done')

if __name__ == '__main__':
  Zotero()

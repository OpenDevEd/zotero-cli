#!/usr/bin/env python3

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

import argparse
import sys
import os
from netrc import netrc
from munch import Munch
import toml
from pyzotero import zotero
import json
import jsonschema

class Zotero(object):
  def __init__(self):
    # global parameters for all commands
    self.parser = argparse.ArgumentParser()
    self.parser.add_argument('--api-key')
    self.parser.add_argument('--config', type=lambda x: x if os.path.exists(x) else self.parser.error(f'config file {x} does not exist'))
    self.parser.add_argument('--library-id', type=int)
    self.parser.add_argument('--library-type', choices=['user', 'group'])
    self.parser.add_argument('--indent', type=int, default=2)

    subparsers = self.parser.add_subparsers(help='commands', dest='command', required=True)
    # add all methods that do not start with _ as a command
    for cmd in dir(self):
      if cmd[0] == '_': continue

      action = getattr(self, cmd)
      if not callable(action): continue

      sp = subparsers.add_parser(cmd.replace('_', '-'), description = action.__doc__, help=action.__doc__)
      # when called with an argparser, the command is expected to add relevant parameters and return
      # the command must have a docstring
      action(sp)

    self.args = self.parser.parse_args()

    # pick up config
    if not self.args.config and os.path.exists('zpapi.toml'):
      self.args.config = 'zpapi.toml'
    if self.args.config:
      with open(self.args.config) as f:
        self.config = toml.load(f, _dict=Munch)
    else:
      self.config = toml.loads('', _dict=Munch)

    # expand command
    for action in sum([(a.choices[self.args.command]._actions if a.dest == 'command' else [a]) for a in self.parser._actions], []):
      if action.dest in [ 'help', 'config']: continue

      if getattr(self.args, action.dest, None) is not None: continue

      value = None

      # first try explicit config
      if value is None and self.args.config:
        value = self.config.get(self.args.command, {}).get(action.dest, self.config.get(action.dest))

      # next, ENV vars. Also picks up from .env
      if value is None:
        value = os.environ.get(f'ZPAPI_{action.dest.upper()}', os.environ.get(f'ZOTERO_{action.dest.upper()}'))

      # last, implicit config
      if value is None:
        value = self.config.get(self.args.command, {}).get(action.dest, self.config.get(action.dest))

      if value is None: continue

      if action.type == int:
        try:
          value = int(value)
        except ValueError:
          self.parser.error(f'{action.dest} must be numeric, not {value}')
      elif action.choices:
        if value not in action.choices:
          self.parser.error(f'{action.dest} must be one of {action.choices}')
      elif action.const == True:
        try:
          value = {
            True: True,
            'true': True,
            'yes': True,
            'on': True,
            False: False,
            'false': False,
            'no': False,
            'off': False,
          }[value]
        except KeyError:
          self.parser.error(f'{action.dest} must be boolean, not {value}')
      elif callable(action.type):
        # file
        pass
      else:
        # string
        pass

      setattr(self.args, action.dest, value)

    if not self.args.api_key: self.parser.error('no API key provided')

    if not self.args.library_type: self.parser.error('no library type provided')

    if not self.args.library_id:
      if self.args.library_type == 'group':
        self.parser.error('no library ID specified')
      else:
        self.args.library_id = zotero.Zotero(1, 'user', self.args.api_key).key_info()['userID']

    self.zotero = zotero.Zotero(self.args.library_id, self.args.library_type, self.args.api_key)

    # call the actual command
    getattr(self, self.args.command.replace('-', '_'))()

  #### THE COMMANDS ####

  def key(self, argparser=None):
    """TODO: document"""

    if argparser: return

    print(json.dumps(self.zotero.key_info(), indent = self.args.indent))

  def items(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('--count', action='store_true')
      argparser.add_argument('--filter')
      argparser.add_argument('--top', action='store_true')
      argparser.add_argument('--validate', type=lambda x: x if os.path.exists(x) else self.parser.error(f'schema file {x} does not exist'), help='json-schema file for all itemtypes, or directory with schema files, one per itemtype')
      return

    if self.args.count and (self.args.filter or self.args.validate or self.args.top):
      self.parser.error('--count cannot be combined with other options')
      return

    if self.args.count:
      print(json.dumps(self.zotero.count_items(), indent=self.args.indent))
      return

    # why not as separate add_argument s?
    args = json.loads(self.args.filter) if self.args.filter else {}

    if self.args.top:
      items = self.zotero.top(**args)
    else:
      items = self.zotero.items(**args)
      if not 'limit' in args: items = self.zotero.everything(items)

    if self.args.validate:
      schemas = {}
      if os.path.isfile(self.args.validate):
        with open(self.args.validate) as f:
          schema = json.load(f)
      # still a bit rudimentary
      for item in items:
        if os.path.isdir(self.args.validate):
          if item['itemType'] not in schemas:
            with open(os.path.join(self.args.validate, item['itemType'] + '.json')) as f:
              schemas[item['itemType']] = json.load(f)
          schema = schemas[item['itemType']]

        jsonschema.validate(instance=item, schema=schema)

    else:
      print(json.dumps(items, indent=self.args.indent))

  def publications(self, argparser=None):
    """TODO: document"""

    if argparser: return

    print(json.dumps(self.zotero.publications(), indent = self.args.indent))

  def trash(self, argparser=None):
    """TODO: document"""

    if argparser: return
    print(json.dumps(self.zotero.trash(), indent = self.args.indent))

  def deleted(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('--filter')
      return

    args = json.loads(self.args.filter) if self.args.filter else {}
    print(json.dumps(self.zotero.deleted(**args), indent = self.args.indent))

  def tags(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('--filter')
      argparser.add_argument('--count')
      return

    args = json.loads(self.args.filter) if self.args.filter else {}
    items = self.zotero.items(**args)
    if not 'limit' in args: items = self.zotero.everything(items)

    if self.args.count:
      for tag in items:
        print(f'{tag} {self.zotero.num_tagitems(tag)}')
    else:
      print(json.dumps(items, indent=self.args.indent))

  def searches(self, argparser=None):
    """TODO: document"""

    if argparser: return
    print(json.dumps(self.zotero.searches(), indent = self.args.indent))

  def saved_search(self, argparser=None):
    """TODO: document"""

    if argparser:
      argparser.add_argument('files', nargs='*')
      return

    if not self.args.files or len(self.args.files) == 0:
      self.parser.error('files are required for saved-search')
      return

    for search in self.args.files:
      print(f'Search file: {search}')

      with open(search) as f:
        searchdefs = json.load(f)
        for searchdef in searchdefs:
          print(f'   Adding: {mydef["name"]}')
          result = self.zotero.saved_search(mydef['name'], mydef['conditions'])
          print(json.dumps(result, indent=self.args.indent))
    print('Done')

if __name__ == '__main__':
  Zotero()
